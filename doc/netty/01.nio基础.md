# NIO 基础
### 1.三大组件
##### 1.1 Channel & Buffer
channel有一点类似于stream,它就是读写数据的双向通道，可以从channel将数据读入buffer，也可以将buffer的数据写入channel。
而之前的stream要么是输入，要么是输出，channel比stream更为底层。

常见的channel有
1. FileChannel
2. DatagramChannel
3. SocketChannel
4. ServerSocketChannel

buffer则用来缓冲读写数据，常见的buffer有
1. ByteBuffer
   1. MappedByteBuffer
   2. DirectByteBuffer
   3. HeapByteBuffer
2. ShortBuffer
3. IntBuffer
4. LongBuffer
5. FloatBuffer
6. DoubleBuffer
##### 1.2 Selecor

**多线程版本**

![image-20241101204010975](E:\java_workspace\java-learn-jdk17\doc\netty\image\selector-多线程版本.png)

多线程版本的缺点

* 内存占用高
* 线程上下文切换成本高
* 只适合连接数少的场景

**线程池版本**

![image-20241101204609274](E:\java_workspace\java-learn-jdk17\doc\netty\image\selector-线程池版本.png)

**selector版本**

![image-20241101204909469](E:\java_workspace\java-learn-jdk17\doc\netty\image\selector-版本.png)

selecor的作用就是配合一个线程来管理多个channel，获取这些channel上发生的事件。这些channel工作在非阻塞模式下，不会让线程吊死在一个channel上。适合连接数特别多，但流量低的场景（low traffic）

调用selector的select（）会阻塞知道channel发生读写就绪事件，这些事件发生，select方法就会返回这些事件交给thread来处理

### 2.ByteBuffer

有一个普通的文本，data.txt,内容为

```txt
1234567890abcd
```

使用fileChannel来读取文件内容

```java
@Slf4j
public class TestByteBuffer {
    public static void main(String[] args) {
        //FileChannel
        //1. 输入输出流
        //2. RandomAccessFile

        try(FileChannel channel = new FileInputStream("data.txt").getChannel()){
            //准备缓冲区
            ByteBuffer buffer = ByteBuffer.allocate(2);
            while(true){
                //从channel读取数据，向buffer写入
                int len = channel.read(buffer);
                if(len == -1){
                    break;
                }
                //打印buffer的内容
                buffer.flip();//切换至读模式
                while (buffer.hasRemaining()){
                    byte b = buffer.get();
                    log.error("读取到的内容：{}" ,(char) b);
                }
                buffer.flip();
            }

        }catch (Exception ignored){
        }
    }
}
```

##### 2.1 byteBuffer正确的使用姿势

1. 向buffer写入数据，例如调用channel.read(buffer)
2. 调用flip()切换至读模式
3. 从buffer读取数据，例如调用buffer.get()
4. 调用clear或compact()切换至写模式
5. 重复1-4步骤

##### 2.2 ByteByffer结构

有以下重要属性

* capacity
* position
* limit

一开始

![image-20241101211952522](E:\java_workspace\java-learn-jdk17\doc\netty\image\byteBuffer初始化.png)

写模式下，position是写入位置，limit等于容量，下图显示写入四个字节后的状态

![image-20241101212202281](E:\java_workspace\java-learn-jdk17\doc\netty\image\byteBuffer写入数据.png)

flip动作发生后，position切换为读取位置，limit切换为读取限制

![image-20241101212557760](E:\java_workspace\java-learn-jdk17\doc\netty\image\byteBuffer写完flip后.png)

读取四个字节后，状态

![image-20241101212727650](E:\java_workspace\java-learn-jdk17\doc\netty\image\byteBuffer读完数据.png)

clear动作发生后

![image-20241101211952522](E:\java_workspace\java-learn-jdk17\doc\netty\image\byteBuffer初始化.png)

compact方法，是把未读完的部分向前压缩，然后切换至写模式

![image-20241101213204615](E:\java_workspace\java-learn-jdk17\doc\netty\image\byteBuffercompact后.png)

##### 2.3 ByteBuffer常见方法

**分配空间**

```java
ByteBuffer allocate = ByteBuffer.allocate(10);//java堆内存，读写效率低，受到GC的影响
ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(10);//直接内存，读写效率高（少一次拷贝），不会受Gc影响，分配效率低
```

**向buffer写入数据**

* 调用channel的read方法
* 调用buffer自己的put方法

```java
int readBytes = channel.read(buf);
buf.put((byte)127);
```

**从buffer中读入数据**

* 调用 channel 的 write 方法
* 调用 buffer 自己的 get 方法

```java
int writeBytes = channel.write(buf);
byte b = buf.get();
```

get 方法会让 position 读指针向后走，如果想重复读取数据

* 可以调用 rewind 方法将 position 重新置为 0
* 或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针

**mark和reset**

mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置

> **注意**
>
> rewind 和 flip 都会清除 mark 位置

**字符串和ByteBuffer互转**

```java
ByteBuffer buffer1 = StandardCharsets.UTF_8.encode("你好");
ByteBuffer buffer2 = Charset.forName("utf-8").encode("你好");

debug(buffer1);
debug(buffer2);

CharBuffer buffer3 = StandardCharsets.UTF_8.decode(buffer1);
System.out.println(buffer3.getClass());
System.out.println(buffer3.toString());
```

 ⚠️ Buffer 的线程安全

> Buffer 是**非线程安全的**

##### 2.5  Scattering Reads

##### 2.6 Gathering Write
